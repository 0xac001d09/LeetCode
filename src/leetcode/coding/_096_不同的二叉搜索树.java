package leetcode.coding;

/**
 * 不同的二叉搜索树 二叉搜索树的最大特性就是 根节点比左孩子大，比右孩子小
 * 思路：
 *      1、最简单的方法，找规律，直接利用卡特兰方程C(2n,n) / (n+1)

 *      2、动态规划，假设n个节点不同二叉树个数为G(n),以i为根节点的不同二叉树个数为f(i)，==> G(n) = f(1)+f(2)+...+f(n)
 *                  当i为根节点时，f(i) = G(i-1) * G(n-i)
 *                  结合这两个公式，实际上就是卡特兰数
 *                  G(n) = G(0)*G(n-1) + G(1)*G(n-2) + ... + G(n-1)*G(0)
 *                  dp[2] = G(2) = G(0)*G(1) + G(1)*G(0)
 *
 *                  dp[i]代表当前i长度为i有几种可能（i从1开始）,当前i个节点可以分成左右两部分，左边可以从0到i-1，右边对应的从i-1到0
 *                  假设左边j个(j需要从1开始，因为i从1开始的)dp[i] = dp[j-1] * dp[i-j]
 *
 *                  初始化 dp[0] = 1，空二叉树也算是一种
 *                        dp[1] = 1,一个节点的时候
 */
public class _096_不同的二叉搜索树 {

    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = dp[1] = 1;

        //当前有多少个节点，长度从2～
        for (int len = 2; len <= n; len++) {
            //以i为根节点的数（根节点不算在左右），左边可能*右边可能
            for (int i = 1; i <= len; i++) {
                dp[len] += dp[i - 1] * dp[len - i];
            }
        }
        return dp[n];
    }
}
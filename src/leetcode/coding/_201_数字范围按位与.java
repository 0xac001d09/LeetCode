package leetcode.coding;

/**
 * 给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。
 *
 * 输入: [5,7]
 * 输出: 4
 *
 * 5=0101
 * 6=0110
 * 7=0111
 *
 * 5 & 6 = 0100=4
 * 4 & 7 = 0100=4
 *
 * 思路：直接暴力写for循环，超时
 *
 * 最低位会有很多数相与，要么是 0 ，要么是 1，而出现了 0 的话相与的结果一定会是 0。因为【0和其他与都是0】
 * 只看所有数的最低位变化情况即可，参与相与的数中最低位要么在第一个数字第一次出现 0 ，要么在第二个数字出现第一次出现 0 。
 *
 * 最低位序列从 1 开始递增, 也就是最右边的一列 101
 * m 5 1 0 1
 *   6 1 1 0
 * n 7 1 1 1
 *         0
 *
 * 此时 m < n，所以至少会有两个数字，所以最低位相与结果一定是 0。
 * 解决了最低位的问题，我们只需要把 m 和 n 同时右移一位。然后继续按照上边的思路考虑新的最低位的结果即可。
 * 而当 m == n 的时候，很明显，结果就是 m 了。
 * 代码中，我们需要用一个变量 zero 记录我们右移的次数，也就是最低位 0 的个数。
 *
 */
public class _201_数字范围按位与 {

    public static int rangeBitwiseAnd(int m, int n) {
        int zeros = 0;
        while (m != n) {
            m >>= 1;
            n >>= 1;
            zeros++;
        }
        return m << zeros;
    }

    public static void main(String[] args) {
        System.out.println(rangeBitwiseAnd(5, 7));
    }
}
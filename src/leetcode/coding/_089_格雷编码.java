package leetcode.coding;

import java.util.ArrayList;
import java.util.List;

/**
 * 这个题可以用镜面反射做，当时没有理解，所以用动态规划思想做了。
 * 比如n=3的时候，有3位
 * 原始n=2的时候，答案为
 * 00 01 11 10
 * 现在变成了三位，首先肯定是在最高位补0，变为
 * 000 001 011 010，这肯定是符合条件的，它们分别对应了数字 0 1 3 2
 * 然后我们要对最高位补1
 * 100 101 111 110，这就不符合条件了，因为010（2）和100差了两位了，
 * 怎么搞呢，我们直接把第四个数字拉过来，后两位别变了，最高位变成和第四个数字不一样即可，也就是直接把010拉过来，最高位改成 1 即可
 *
 * 如下
 * 000 -> 100
 * 001 -> 101
 * 011 -> 111
 * 010 -> 110
 *
 * 那么添加顺序是？ 左边的正常添加，右边的需要倒过来添加
 * 因为左边添加完010，需要添加110，也就是右边最后一个，所以是倒过来遍历list
 *
 * 左边部分的最高位是0，它转化为数字和 n=2 的情况是一样的
 * 右边数字的最高位是1，他就是左边的值加上 2^(3-1),也就是2^(n-1)，也就是加上1左移n-1位， 1 << n-1,n是当前的
 *
 */
public class _089_格雷编码 {

    public List<Integer> grayCode(int n) {
        ArrayList<Integer> list = new ArrayList<>();
        list.add(0);
        for (int i = 0; i < n; i++) {
            int add = 1 << i; //右侧每个数都要加上多少，左移i，i代表当前搞几位的
            for (int j = list.size() - 1; j >= 0; j--) {
                list.add(list.get(j) + add);
            }
        }
        return list;
    }

}
package leetcode.coding;

/**
 * 非常经典的面试问题
 *
 * 直接看李永乐老师视频https://www.bilibili.com/video/av96214853
 */
public class _887_鸡蛋掉落 {
    // 扔 1 次，覆盖 1 层。 扔 2 次，覆盖 3 层。 扔 3 次，覆盖 6 层。 即：1 + 2 + 3 + ... + 14 > 100
    // 我没有太看懂，可以再讲解以下吗？为什么会覆盖1，3，6层呀？
    // 这个比二分递归那个代码简洁多了，但为什么没有用二分感觉好像为什么不会时间变长呢？ 好意外，真厉害！

    //K个鸡蛋，N层楼
    public int superEggDrop(int K, int N) {
        int cnt = 1;    //最少需要测几次
        //当还没测完这N层时，就给我一直测
        while (helper(K, cnt) <= N) {
            cnt++;
        }
        return cnt;
    }

    // 计算 K 个鸡蛋，扔 T 次，可以覆盖多少个区间
    private int helper(int K, int T) {
        //如果只能扔1次，只能测出两个区间
        if (T == 1) return 2;
        //如果只有一个鸡蛋了，能扔T次，可以确定T+1个区间
        if (K == 1) return T + 1;
        //鸡蛋碎了和鸡蛋没碎两种情况
        return helper(K - 1, T - 1) + helper(K, T - 1);
    }

    /*
    T 层，N个鸡蛋，M(T,N)表示至少要扔多少次才能找到这个临界楼层，假定扔M次，M是关于T和N的一个函数
    给定1 ～ T层，我们中间选取一个楼层 k
    1 ～ k ～ T
    如果在第k层碎了，那么我们只要看前面的楼层,那么还需要扔多少次鸡蛋，才能确定前面的k层哪个是临界楼层呢，那就要看 M(k,N-1)
    如果在第k层没碎，那么我们只要看后面的楼层,那么还需要扔多少次鸡蛋，才能确定后面的k层哪个是临界楼层呢，那就要看 M(T-k,N)
    那么 max(M(k,N-1), M(T-k,N)) + 1 = Mk 表示当一个鸡蛋扔到第k层时，原来是T层楼和N个鸡蛋，你需要扔的鸡蛋的个数至少扔几次
    枚举 M(T,N) = min(M1,M2,M3...Mn)

    //TODO
     */

    /*
    这 K 个鸡蛋，F 值满足的特点是：
    在所有小于等于 F 的楼层扔下它不破碎；在所有大于 F 的楼层扔下它一定会破碎；
    F值是确定的，但它不是题目要我们求的。题目要我们求的是找到这个 F 值的最小实验次数。

    在一个数组（长度为 NN）里查找一个数，找到某个数可以用线性查找，最好情况下，下标为 0 的位置就是要找的元素
    但是在计算复杂度的时候，需要考虑到最差情况，即看到最后一个位置的时候，才找到这个元素，因此至少执行数组长度这么多次的查找，才能找到；

    题目中只有一个限制：鸡蛋的个数，给定鸡蛋个数，求找到这个F所需最少的实验次数是多少？
    如果鸡蛋无穷多，相当于没有限制，可以用二分做，如果只有一个鸡蛋，只能一层一层找,如果鸡蛋的个数有若干个，该怎么利用好这些鸡蛋


     */

}
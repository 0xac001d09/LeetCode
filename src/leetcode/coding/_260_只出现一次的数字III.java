package leetcode.coding;

/**
 * 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。
 *
 * 思路：位运算（用到lowbit）
 * 1、先把所有元素进行异或，得到一个值，这个值必定不为0，因为有两个不同的数字
 * 2、取异或值最后一个二进制位为1的数字作为mask，如果是1则表示两个数字在这一位上不同。
 *      lowbit(x) 得到的是二进制表达式中最低位的1对应的值，比如6的二进制是110， lowbit(6) = 2，
 * 3、通过与这个mask进行与操作，如果为0的分为一个数组，为1的分为另一个数组。
 *    这样就把问题降低成了：“有一个数组每个数字都出现两次，有一个数字只出现了一次，求出该数字”。
 *    对这两个子问题分别进行全异或就可以得到两个解。也就是最终的数组了。
 *
 * 简明扼要
 * 1.对所有数字异或,一样的数字抵消,出现一次的两个数字异或运算后必定不为0;
 * 2.这个数字和相反数做与运算得到一个二进制位最右边一位为1的数字;    (也就是两者出现不等的地方,异或运算。。相同为0，不同为1)
 * 3.mask和数组的每个数字做与运算,等于0的分为一组,等于mask的分为一组,同时也将两个不一样的数字分开;
 * 4.完结。
 */
public class _260_只出现一次的数字III {

    public int[] singleNumber(int[] nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        //get lowbit
        int mask = xor & (-xor);
        int[] res = new int[2];
        for (int num : nums) {
            if ((num & mask) == 0) {
                res[0] ^= num;
            } else {
                res[1] ^= num;
            }
        }
        return res;
    }
}